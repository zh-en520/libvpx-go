// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Tue, 05 Sep 2017 19:51:53 MSK.
// By https://git.io/c-for-go. DO NOT EDIT.

package vpx

/*
#cgo pkg-config: vpx
#include <vpx/vpx_encoder.h>
#include <vpx/vpx_decoder.h>
#include <vpx/vp8.h>
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocFixedBufMemory allocates memory for type C.vpx_fixed_buf_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFixedBufMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFixedBufValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFixedBufValue = unsafe.Sizeof([1]C.vpx_fixed_buf_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FixedBuf) Ref() *C.vpx_fixed_buf_t {
	if x == nil {
		return nil
	}
	return x.refeac28dc0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FixedBuf) Free() {
	if x != nil && x.allocseac28dc0 != nil {
		x.allocseac28dc0.(*cgoAllocMap).Free()
		x.refeac28dc0 = nil
	}
}

// NewFixedBufRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFixedBufRef(ref unsafe.Pointer) *FixedBuf {
	if ref == nil {
		return nil
	}
	obj := new(FixedBuf)
	obj.refeac28dc0 = (*C.vpx_fixed_buf_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FixedBuf) PassRef() (*C.vpx_fixed_buf_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeac28dc0 != nil {
		return x.refeac28dc0, nil
	}
	memeac28dc0 := allocFixedBufMemory(1)
	refeac28dc0 := (*C.vpx_fixed_buf_t)(memeac28dc0)
	allocseac28dc0 := new(cgoAllocMap)
	allocseac28dc0.Add(memeac28dc0)

	var cbuf_allocs *cgoAllocMap
	refeac28dc0.buf, cbuf_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Buf)), cgoAllocsUnknown
	allocseac28dc0.Borrow(cbuf_allocs)

	var csz_allocs *cgoAllocMap
	refeac28dc0.sz, csz_allocs = (C.size_t)(x.Sz), cgoAllocsUnknown
	allocseac28dc0.Borrow(csz_allocs)

	x.refeac28dc0 = refeac28dc0
	x.allocseac28dc0 = allocseac28dc0
	return refeac28dc0, allocseac28dc0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FixedBuf) PassValue() (C.vpx_fixed_buf_t, *cgoAllocMap) {
	if x.refeac28dc0 != nil {
		return *x.refeac28dc0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FixedBuf) Deref() {
	if x.refeac28dc0 == nil {
		return
	}
	x.Buf = (unsafe.Pointer)(unsafe.Pointer(x.refeac28dc0.buf))
	x.Sz = (uint)(x.refeac28dc0.sz)
}

// allocCodecCxPktMemory allocates memory for type C.vpx_codec_cx_pkt_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCodecCxPktMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCodecCxPktValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCodecCxPktValue = unsafe.Sizeof([1]C.vpx_codec_cx_pkt_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CodecCxPkt) Ref() *C.vpx_codec_cx_pkt_t {
	if x == nil {
		return nil
	}
	return x.refa671fc83
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CodecCxPkt) Free() {
	if x != nil && x.allocsa671fc83 != nil {
		x.allocsa671fc83.(*cgoAllocMap).Free()
		x.refa671fc83 = nil
	}
}

// NewCodecCxPktRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCodecCxPktRef(ref unsafe.Pointer) *CodecCxPkt {
	if ref == nil {
		return nil
	}
	obj := new(CodecCxPkt)
	obj.refa671fc83 = (*C.vpx_codec_cx_pkt_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CodecCxPkt) PassRef() (*C.vpx_codec_cx_pkt_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa671fc83 != nil {
		return x.refa671fc83, nil
	}
	mema671fc83 := allocCodecCxPktMemory(1)
	refa671fc83 := (*C.vpx_codec_cx_pkt_t)(mema671fc83)
	allocsa671fc83 := new(cgoAllocMap)
	allocsa671fc83.Add(mema671fc83)

	var ckind_allocs *cgoAllocMap
	refa671fc83.kind, ckind_allocs = (C.enum_vpx_codec_cx_pkt_kind)(x.Kind), cgoAllocsUnknown
	allocsa671fc83.Borrow(ckind_allocs)

	x.refa671fc83 = refa671fc83
	x.allocsa671fc83 = allocsa671fc83
	return refa671fc83, allocsa671fc83

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CodecCxPkt) PassValue() (C.vpx_codec_cx_pkt_t, *cgoAllocMap) {
	if x.refa671fc83 != nil {
		return *x.refa671fc83, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CodecCxPkt) Deref() {
	if x.refa671fc83 == nil {
		return
	}
	x.Kind = (CodecCxPktKind)(x.refa671fc83.kind)
}

func (x CodecEncOutputCxPktCbFn) PassRef() (ref *C.vpx_codec_enc_output_cx_pkt_cb_fn_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if codecEncOutputCxPktCbFn947769C1Func == nil {
		codecEncOutputCxPktCbFn947769C1Func = x
	}
	return (*C.vpx_codec_enc_output_cx_pkt_cb_fn_t)(C.vpx_codec_enc_output_cx_pkt_cb_fn_t_947769c1), nil
}

func (x CodecEncOutputCxPktCbFn) PassValue() (ref C.vpx_codec_enc_output_cx_pkt_cb_fn_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if codecEncOutputCxPktCbFn947769C1Func == nil {
		codecEncOutputCxPktCbFn947769C1Func = x
	}
	return (C.vpx_codec_enc_output_cx_pkt_cb_fn_t)(C.vpx_codec_enc_output_cx_pkt_cb_fn_t_947769c1), nil
}

func NewCodecEncOutputCxPktCbFnRef(ref unsafe.Pointer) *CodecEncOutputCxPktCbFn {
	return (*CodecEncOutputCxPktCbFn)(ref)
}

//export codecEncOutputCxPktCbFn947769C1
func codecEncOutputCxPktCbFn947769C1(cpkt *C.vpx_codec_cx_pkt_t, cuserData unsafe.Pointer) {
	if codecEncOutputCxPktCbFn947769C1Func != nil {
		pkt947769c1 := NewCodecCxPktRef(unsafe.Pointer(cpkt))
		userData947769c1 := (unsafe.Pointer)(unsafe.Pointer(cuserData))
		codecEncOutputCxPktCbFn947769C1Func(pkt947769c1, userData947769c1)
		return
	}
	panic("callback func has not been set (race?)")
}

var codecEncOutputCxPktCbFn947769C1Func CodecEncOutputCxPktCbFn

// allocCodecPrivOutputCxPktCbPairMemory allocates memory for type C.vpx_codec_priv_output_cx_pkt_cb_pair_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCodecPrivOutputCxPktCbPairMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCodecPrivOutputCxPktCbPairValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCodecPrivOutputCxPktCbPairValue = unsafe.Sizeof([1]C.vpx_codec_priv_output_cx_pkt_cb_pair_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CodecPrivOutputCxPktCbPair) Ref() *C.vpx_codec_priv_output_cx_pkt_cb_pair_t {
	if x == nil {
		return nil
	}
	return x.ref5727a29d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CodecPrivOutputCxPktCbPair) Free() {
	if x != nil && x.allocs5727a29d != nil {
		x.allocs5727a29d.(*cgoAllocMap).Free()
		x.ref5727a29d = nil
	}
}

// NewCodecPrivOutputCxPktCbPairRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCodecPrivOutputCxPktCbPairRef(ref unsafe.Pointer) *CodecPrivOutputCxPktCbPair {
	if ref == nil {
		return nil
	}
	obj := new(CodecPrivOutputCxPktCbPair)
	obj.ref5727a29d = (*C.vpx_codec_priv_output_cx_pkt_cb_pair_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CodecPrivOutputCxPktCbPair) PassRef() (*C.vpx_codec_priv_output_cx_pkt_cb_pair_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5727a29d != nil {
		return x.ref5727a29d, nil
	}
	mem5727a29d := allocCodecPrivOutputCxPktCbPairMemory(1)
	ref5727a29d := (*C.vpx_codec_priv_output_cx_pkt_cb_pair_t)(mem5727a29d)
	allocs5727a29d := new(cgoAllocMap)
	allocs5727a29d.Add(mem5727a29d)

	var coutput_cx_pkt_allocs *cgoAllocMap
	ref5727a29d.output_cx_pkt, coutput_cx_pkt_allocs = x.OutputCxPkt.PassValue()
	allocs5727a29d.Borrow(coutput_cx_pkt_allocs)

	var cuser_priv_allocs *cgoAllocMap
	ref5727a29d.user_priv, cuser_priv_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.UserPriv)), cgoAllocsUnknown
	allocs5727a29d.Borrow(cuser_priv_allocs)

	x.ref5727a29d = ref5727a29d
	x.allocs5727a29d = allocs5727a29d
	return ref5727a29d, allocs5727a29d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CodecPrivOutputCxPktCbPair) PassValue() (C.vpx_codec_priv_output_cx_pkt_cb_pair_t, *cgoAllocMap) {
	if x.ref5727a29d != nil {
		return *x.ref5727a29d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CodecPrivOutputCxPktCbPair) Deref() {
	if x.ref5727a29d == nil {
		return
	}
	x.OutputCxPkt = *NewCodecEncOutputCxPktCbFnRef(unsafe.Pointer(&x.ref5727a29d.output_cx_pkt))
	x.UserPriv = (unsafe.Pointer)(unsafe.Pointer(x.ref5727a29d.user_priv))
}

// allocRationalMemory allocates memory for type C.vpx_rational_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRationalMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRationalValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRationalValue = unsafe.Sizeof([1]C.vpx_rational_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Rational) Ref() *C.vpx_rational_t {
	if x == nil {
		return nil
	}
	return x.ref48ce5779
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Rational) Free() {
	if x != nil && x.allocs48ce5779 != nil {
		x.allocs48ce5779.(*cgoAllocMap).Free()
		x.ref48ce5779 = nil
	}
}

// NewRationalRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRationalRef(ref unsafe.Pointer) *Rational {
	if ref == nil {
		return nil
	}
	obj := new(Rational)
	obj.ref48ce5779 = (*C.vpx_rational_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Rational) PassRef() (*C.vpx_rational_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref48ce5779 != nil {
		return x.ref48ce5779, nil
	}
	mem48ce5779 := allocRationalMemory(1)
	ref48ce5779 := (*C.vpx_rational_t)(mem48ce5779)
	allocs48ce5779 := new(cgoAllocMap)
	allocs48ce5779.Add(mem48ce5779)

	var cnum_allocs *cgoAllocMap
	ref48ce5779.num, cnum_allocs = (C.int)(x.Num), cgoAllocsUnknown
	allocs48ce5779.Borrow(cnum_allocs)

	var cden_allocs *cgoAllocMap
	ref48ce5779.den, cden_allocs = (C.int)(x.Den), cgoAllocsUnknown
	allocs48ce5779.Borrow(cden_allocs)

	x.ref48ce5779 = ref48ce5779
	x.allocs48ce5779 = allocs48ce5779
	return ref48ce5779, allocs48ce5779

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Rational) PassValue() (C.vpx_rational_t, *cgoAllocMap) {
	if x.ref48ce5779 != nil {
		return *x.ref48ce5779, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Rational) Deref() {
	if x.ref48ce5779 == nil {
		return
	}
	x.Num = (int32)(x.ref48ce5779.num)
	x.Den = (int32)(x.ref48ce5779.den)
}

// allocCodecEncCfgMemory allocates memory for type C.vpx_codec_enc_cfg_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCodecEncCfgMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCodecEncCfgValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCodecEncCfgValue = unsafe.Sizeof([1]C.vpx_codec_enc_cfg_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CodecEncCfg) Ref() *C.vpx_codec_enc_cfg_t {
	if x == nil {
		return nil
	}
	return x.ref37e25db9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CodecEncCfg) Free() {
	if x != nil && x.allocs37e25db9 != nil {
		x.allocs37e25db9.(*cgoAllocMap).Free()
		x.ref37e25db9 = nil
	}
}

// NewCodecEncCfgRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCodecEncCfgRef(ref unsafe.Pointer) *CodecEncCfg {
	if ref == nil {
		return nil
	}
	obj := new(CodecEncCfg)
	obj.ref37e25db9 = (*C.vpx_codec_enc_cfg_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CodecEncCfg) PassRef() (*C.vpx_codec_enc_cfg_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref37e25db9 != nil {
		return x.ref37e25db9, nil
	}
	mem37e25db9 := allocCodecEncCfgMemory(1)
	ref37e25db9 := (*C.vpx_codec_enc_cfg_t)(mem37e25db9)
	allocs37e25db9 := new(cgoAllocMap)
	allocs37e25db9.Add(mem37e25db9)

	var cg_usage_allocs *cgoAllocMap
	ref37e25db9.g_usage, cg_usage_allocs = (C.uint)(x.GUsage), cgoAllocsUnknown
	allocs37e25db9.Borrow(cg_usage_allocs)

	var cg_threads_allocs *cgoAllocMap
	ref37e25db9.g_threads, cg_threads_allocs = (C.uint)(x.GThreads), cgoAllocsUnknown
	allocs37e25db9.Borrow(cg_threads_allocs)

	var cg_profile_allocs *cgoAllocMap
	ref37e25db9.g_profile, cg_profile_allocs = (C.uint)(x.GProfile), cgoAllocsUnknown
	allocs37e25db9.Borrow(cg_profile_allocs)

	var cg_w_allocs *cgoAllocMap
	ref37e25db9.g_w, cg_w_allocs = (C.uint)(x.GW), cgoAllocsUnknown
	allocs37e25db9.Borrow(cg_w_allocs)

	var cg_h_allocs *cgoAllocMap
	ref37e25db9.g_h, cg_h_allocs = (C.uint)(x.GH), cgoAllocsUnknown
	allocs37e25db9.Borrow(cg_h_allocs)

	var cg_bit_depth_allocs *cgoAllocMap
	ref37e25db9.g_bit_depth, cg_bit_depth_allocs = (C.vpx_bit_depth_t)(x.GBitDepth), cgoAllocsUnknown
	allocs37e25db9.Borrow(cg_bit_depth_allocs)

	var cg_input_bit_depth_allocs *cgoAllocMap
	ref37e25db9.g_input_bit_depth, cg_input_bit_depth_allocs = (C.uint)(x.GInputBitDepth), cgoAllocsUnknown
	allocs37e25db9.Borrow(cg_input_bit_depth_allocs)

	var cg_timebase_allocs *cgoAllocMap
	ref37e25db9.g_timebase, cg_timebase_allocs = x.GTimebase.PassValue()
	allocs37e25db9.Borrow(cg_timebase_allocs)

	var cg_error_resilient_allocs *cgoAllocMap
	ref37e25db9.g_error_resilient, cg_error_resilient_allocs = (C.vpx_codec_er_flags_t)(x.GErrorResilient), cgoAllocsUnknown
	allocs37e25db9.Borrow(cg_error_resilient_allocs)

	var cg_pass_allocs *cgoAllocMap
	ref37e25db9.g_pass, cg_pass_allocs = (C.enum_vpx_enc_pass)(x.GPass), cgoAllocsUnknown
	allocs37e25db9.Borrow(cg_pass_allocs)

	var cg_lag_in_frames_allocs *cgoAllocMap
	ref37e25db9.g_lag_in_frames, cg_lag_in_frames_allocs = (C.uint)(x.GLagInFrames), cgoAllocsUnknown
	allocs37e25db9.Borrow(cg_lag_in_frames_allocs)

	var crc_dropframe_thresh_allocs *cgoAllocMap
	ref37e25db9.rc_dropframe_thresh, crc_dropframe_thresh_allocs = (C.uint)(x.RcDropframeThresh), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_dropframe_thresh_allocs)

	var crc_resize_allowed_allocs *cgoAllocMap
	ref37e25db9.rc_resize_allowed, crc_resize_allowed_allocs = (C.uint)(x.RcResizeAllowed), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_resize_allowed_allocs)

	var crc_scaled_width_allocs *cgoAllocMap
	ref37e25db9.rc_scaled_width, crc_scaled_width_allocs = (C.uint)(x.RcScaledWidth), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_scaled_width_allocs)

	var crc_scaled_height_allocs *cgoAllocMap
	ref37e25db9.rc_scaled_height, crc_scaled_height_allocs = (C.uint)(x.RcScaledHeight), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_scaled_height_allocs)

	var crc_resize_up_thresh_allocs *cgoAllocMap
	ref37e25db9.rc_resize_up_thresh, crc_resize_up_thresh_allocs = (C.uint)(x.RcResizeUpThresh), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_resize_up_thresh_allocs)

	var crc_resize_down_thresh_allocs *cgoAllocMap
	ref37e25db9.rc_resize_down_thresh, crc_resize_down_thresh_allocs = (C.uint)(x.RcResizeDownThresh), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_resize_down_thresh_allocs)

	var crc_end_usage_allocs *cgoAllocMap
	ref37e25db9.rc_end_usage, crc_end_usage_allocs = (C.enum_vpx_rc_mode)(x.RcEndUsage), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_end_usage_allocs)

	var crc_twopass_stats_in_allocs *cgoAllocMap
	ref37e25db9.rc_twopass_stats_in, crc_twopass_stats_in_allocs = x.RcTwopassStatsIn.PassValue()
	allocs37e25db9.Borrow(crc_twopass_stats_in_allocs)

	var crc_firstpass_mb_stats_in_allocs *cgoAllocMap
	ref37e25db9.rc_firstpass_mb_stats_in, crc_firstpass_mb_stats_in_allocs = x.RcFirstpassMbStatsIn.PassValue()
	allocs37e25db9.Borrow(crc_firstpass_mb_stats_in_allocs)

	var crc_target_bitrate_allocs *cgoAllocMap
	ref37e25db9.rc_target_bitrate, crc_target_bitrate_allocs = (C.uint)(x.RcTargetBitrate), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_target_bitrate_allocs)

	var crc_min_quantizer_allocs *cgoAllocMap
	ref37e25db9.rc_min_quantizer, crc_min_quantizer_allocs = (C.uint)(x.RcMinQuantizer), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_min_quantizer_allocs)

	var crc_max_quantizer_allocs *cgoAllocMap
	ref37e25db9.rc_max_quantizer, crc_max_quantizer_allocs = (C.uint)(x.RcMaxQuantizer), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_max_quantizer_allocs)

	var crc_undershoot_pct_allocs *cgoAllocMap
	ref37e25db9.rc_undershoot_pct, crc_undershoot_pct_allocs = (C.uint)(x.RcUndershootPct), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_undershoot_pct_allocs)

	var crc_overshoot_pct_allocs *cgoAllocMap
	ref37e25db9.rc_overshoot_pct, crc_overshoot_pct_allocs = (C.uint)(x.RcOvershootPct), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_overshoot_pct_allocs)

	var crc_buf_sz_allocs *cgoAllocMap
	ref37e25db9.rc_buf_sz, crc_buf_sz_allocs = (C.uint)(x.RcBufSz), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_buf_sz_allocs)

	var crc_buf_initial_sz_allocs *cgoAllocMap
	ref37e25db9.rc_buf_initial_sz, crc_buf_initial_sz_allocs = (C.uint)(x.RcBufInitialSz), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_buf_initial_sz_allocs)

	var crc_buf_optimal_sz_allocs *cgoAllocMap
	ref37e25db9.rc_buf_optimal_sz, crc_buf_optimal_sz_allocs = (C.uint)(x.RcBufOptimalSz), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_buf_optimal_sz_allocs)

	var crc_2pass_vbr_bias_pct_allocs *cgoAllocMap
	ref37e25db9.rc_2pass_vbr_bias_pct, crc_2pass_vbr_bias_pct_allocs = (C.uint)(x.Rc2passVbrBiasPct), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_2pass_vbr_bias_pct_allocs)

	var crc_2pass_vbr_minsection_pct_allocs *cgoAllocMap
	ref37e25db9.rc_2pass_vbr_minsection_pct, crc_2pass_vbr_minsection_pct_allocs = (C.uint)(x.Rc2passVbrMinsectionPct), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_2pass_vbr_minsection_pct_allocs)

	var crc_2pass_vbr_maxsection_pct_allocs *cgoAllocMap
	ref37e25db9.rc_2pass_vbr_maxsection_pct, crc_2pass_vbr_maxsection_pct_allocs = (C.uint)(x.Rc2passVbrMaxsectionPct), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_2pass_vbr_maxsection_pct_allocs)

	var ckf_mode_allocs *cgoAllocMap
	ref37e25db9.kf_mode, ckf_mode_allocs = (C.enum_vpx_kf_mode)(x.KfMode), cgoAllocsUnknown
	allocs37e25db9.Borrow(ckf_mode_allocs)

	var ckf_min_dist_allocs *cgoAllocMap
	ref37e25db9.kf_min_dist, ckf_min_dist_allocs = (C.uint)(x.KfMinDist), cgoAllocsUnknown
	allocs37e25db9.Borrow(ckf_min_dist_allocs)

	var ckf_max_dist_allocs *cgoAllocMap
	ref37e25db9.kf_max_dist, ckf_max_dist_allocs = (C.uint)(x.KfMaxDist), cgoAllocsUnknown
	allocs37e25db9.Borrow(ckf_max_dist_allocs)

	var css_number_layers_allocs *cgoAllocMap
	ref37e25db9.ss_number_layers, css_number_layers_allocs = (C.uint)(x.SsNumberLayers), cgoAllocsUnknown
	allocs37e25db9.Borrow(css_number_layers_allocs)

	var css_enable_auto_alt_ref_allocs *cgoAllocMap
	ref37e25db9.ss_enable_auto_alt_ref, css_enable_auto_alt_ref_allocs = *(*[5]C.int)(unsafe.Pointer(&x.SsEnableAutoAltRef)), cgoAllocsUnknown
	allocs37e25db9.Borrow(css_enable_auto_alt_ref_allocs)

	var css_target_bitrate_allocs *cgoAllocMap
	ref37e25db9.ss_target_bitrate, css_target_bitrate_allocs = *(*[5]C.uint)(unsafe.Pointer(&x.SsTargetBitrate)), cgoAllocsUnknown
	allocs37e25db9.Borrow(css_target_bitrate_allocs)

	var cts_number_layers_allocs *cgoAllocMap
	ref37e25db9.ts_number_layers, cts_number_layers_allocs = (C.uint)(x.TsNumberLayers), cgoAllocsUnknown
	allocs37e25db9.Borrow(cts_number_layers_allocs)

	var cts_target_bitrate_allocs *cgoAllocMap
	ref37e25db9.ts_target_bitrate, cts_target_bitrate_allocs = *(*[5]C.uint)(unsafe.Pointer(&x.TsTargetBitrate)), cgoAllocsUnknown
	allocs37e25db9.Borrow(cts_target_bitrate_allocs)

	var cts_rate_decimator_allocs *cgoAllocMap
	ref37e25db9.ts_rate_decimator, cts_rate_decimator_allocs = *(*[5]C.uint)(unsafe.Pointer(&x.TsRateDecimator)), cgoAllocsUnknown
	allocs37e25db9.Borrow(cts_rate_decimator_allocs)

	var cts_periodicity_allocs *cgoAllocMap
	ref37e25db9.ts_periodicity, cts_periodicity_allocs = (C.uint)(x.TsPeriodicity), cgoAllocsUnknown
	allocs37e25db9.Borrow(cts_periodicity_allocs)

	var cts_layer_id_allocs *cgoAllocMap
	ref37e25db9.ts_layer_id, cts_layer_id_allocs = *(*[16]C.uint)(unsafe.Pointer(&x.TsLayerID)), cgoAllocsUnknown
	allocs37e25db9.Borrow(cts_layer_id_allocs)

	var clayer_target_bitrate_allocs *cgoAllocMap
	ref37e25db9.layer_target_bitrate, clayer_target_bitrate_allocs = *(*[12]C.uint)(unsafe.Pointer(&x.LayerTargetBitrate)), cgoAllocsUnknown
	allocs37e25db9.Borrow(clayer_target_bitrate_allocs)

	var ctemporal_layering_mode_allocs *cgoAllocMap
	ref37e25db9.temporal_layering_mode, ctemporal_layering_mode_allocs = (C.int)(x.TemporalLayeringMode), cgoAllocsUnknown
	allocs37e25db9.Borrow(ctemporal_layering_mode_allocs)

	x.ref37e25db9 = ref37e25db9
	x.allocs37e25db9 = allocs37e25db9
	return ref37e25db9, allocs37e25db9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CodecEncCfg) PassValue() (C.vpx_codec_enc_cfg_t, *cgoAllocMap) {
	if x.ref37e25db9 != nil {
		return *x.ref37e25db9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CodecEncCfg) Deref() {
	if x.ref37e25db9 == nil {
		return
	}
	x.GUsage = (uint32)(x.ref37e25db9.g_usage)
	x.GThreads = (uint32)(x.ref37e25db9.g_threads)
	x.GProfile = (uint32)(x.ref37e25db9.g_profile)
	x.GW = (uint32)(x.ref37e25db9.g_w)
	x.GH = (uint32)(x.ref37e25db9.g_h)
	x.GBitDepth = (BitDepth)(x.ref37e25db9.g_bit_depth)
	x.GInputBitDepth = (uint32)(x.ref37e25db9.g_input_bit_depth)
	x.GTimebase = *NewRationalRef(unsafe.Pointer(&x.ref37e25db9.g_timebase))
	x.GErrorResilient = (CodecErFlags)(x.ref37e25db9.g_error_resilient)
	x.GPass = (EncPass)(x.ref37e25db9.g_pass)
	x.GLagInFrames = (uint32)(x.ref37e25db9.g_lag_in_frames)
	x.RcDropframeThresh = (uint32)(x.ref37e25db9.rc_dropframe_thresh)
	x.RcResizeAllowed = (uint32)(x.ref37e25db9.rc_resize_allowed)
	x.RcScaledWidth = (uint32)(x.ref37e25db9.rc_scaled_width)
	x.RcScaledHeight = (uint32)(x.ref37e25db9.rc_scaled_height)
	x.RcResizeUpThresh = (uint32)(x.ref37e25db9.rc_resize_up_thresh)
	x.RcResizeDownThresh = (uint32)(x.ref37e25db9.rc_resize_down_thresh)
	x.RcEndUsage = (RcMode)(x.ref37e25db9.rc_end_usage)
	x.RcTwopassStatsIn = *NewFixedBufRef(unsafe.Pointer(&x.ref37e25db9.rc_twopass_stats_in))
	x.RcFirstpassMbStatsIn = *NewFixedBufRef(unsafe.Pointer(&x.ref37e25db9.rc_firstpass_mb_stats_in))
	x.RcTargetBitrate = (uint32)(x.ref37e25db9.rc_target_bitrate)
	x.RcMinQuantizer = (uint32)(x.ref37e25db9.rc_min_quantizer)
	x.RcMaxQuantizer = (uint32)(x.ref37e25db9.rc_max_quantizer)
	x.RcUndershootPct = (uint32)(x.ref37e25db9.rc_undershoot_pct)
	x.RcOvershootPct = (uint32)(x.ref37e25db9.rc_overshoot_pct)
	x.RcBufSz = (uint32)(x.ref37e25db9.rc_buf_sz)
	x.RcBufInitialSz = (uint32)(x.ref37e25db9.rc_buf_initial_sz)
	x.RcBufOptimalSz = (uint32)(x.ref37e25db9.rc_buf_optimal_sz)
	x.Rc2passVbrBiasPct = (uint32)(x.ref37e25db9.rc_2pass_vbr_bias_pct)
	x.Rc2passVbrMinsectionPct = (uint32)(x.ref37e25db9.rc_2pass_vbr_minsection_pct)
	x.Rc2passVbrMaxsectionPct = (uint32)(x.ref37e25db9.rc_2pass_vbr_maxsection_pct)
	x.KfMode = (KfMode)(x.ref37e25db9.kf_mode)
	x.KfMinDist = (uint32)(x.ref37e25db9.kf_min_dist)
	x.KfMaxDist = (uint32)(x.ref37e25db9.kf_max_dist)
	x.SsNumberLayers = (uint32)(x.ref37e25db9.ss_number_layers)
	x.SsEnableAutoAltRef = *(*[5]int32)(unsafe.Pointer(&x.ref37e25db9.ss_enable_auto_alt_ref))
	x.SsTargetBitrate = *(*[5]uint32)(unsafe.Pointer(&x.ref37e25db9.ss_target_bitrate))
	x.TsNumberLayers = (uint32)(x.ref37e25db9.ts_number_layers)
	x.TsTargetBitrate = *(*[5]uint32)(unsafe.Pointer(&x.ref37e25db9.ts_target_bitrate))
	x.TsRateDecimator = *(*[5]uint32)(unsafe.Pointer(&x.ref37e25db9.ts_rate_decimator))
	x.TsPeriodicity = (uint32)(x.ref37e25db9.ts_periodicity)
	x.TsLayerID = *(*[16]uint32)(unsafe.Pointer(&x.ref37e25db9.ts_layer_id))
	x.LayerTargetBitrate = *(*[12]uint32)(unsafe.Pointer(&x.ref37e25db9.layer_target_bitrate))
	x.TemporalLayeringMode = (int32)(x.ref37e25db9.temporal_layering_mode)
}

// Ref returns a reference to C object as it is.
func (x *SvcExtraCfg) Ref() *C.vpx_svc_extra_cfg_t {
	if x == nil {
		return nil
	}
	return (*C.vpx_svc_extra_cfg_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *SvcExtraCfg) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewSvcExtraCfgRef converts the C object reference into a raw struct reference without wrapping.
func NewSvcExtraCfgRef(ref unsafe.Pointer) *SvcExtraCfg {
	return (*SvcExtraCfg)(ref)
}

// NewSvcExtraCfg allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewSvcExtraCfg() *SvcExtraCfg {
	return (*SvcExtraCfg)(allocSvcExtraCfgMemory(1))
}

// allocSvcExtraCfgMemory allocates memory for type C.vpx_svc_extra_cfg_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSvcExtraCfgMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSvcExtraCfgValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSvcExtraCfgValue = unsafe.Sizeof([1]C.vpx_svc_extra_cfg_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *SvcExtraCfg) PassRef() *C.vpx_svc_extra_cfg_t {
	if x == nil {
		x = (*SvcExtraCfg)(allocSvcExtraCfgMemory(1))
	}
	return (*C.vpx_svc_extra_cfg_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CodecIface) Ref() *C.vpx_codec_iface_t {
	if x == nil {
		return nil
	}
	return (*C.vpx_codec_iface_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CodecIface) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCodecIfaceRef converts the C object reference into a raw struct reference without wrapping.
func NewCodecIfaceRef(ref unsafe.Pointer) *CodecIface {
	return (*CodecIface)(ref)
}

// NewCodecIface allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCodecIface() *CodecIface {
	return (*CodecIface)(allocCodecIfaceMemory(1))
}

// allocCodecIfaceMemory allocates memory for type C.vpx_codec_iface_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCodecIfaceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCodecIfaceValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCodecIfaceValue = unsafe.Sizeof([1]C.vpx_codec_iface_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CodecIface) PassRef() *C.vpx_codec_iface_t {
	if x == nil {
		x = (*CodecIface)(allocCodecIfaceMemory(1))
	}
	return (*C.vpx_codec_iface_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CodecPriv) Ref() *C.vpx_codec_priv_t {
	if x == nil {
		return nil
	}
	return (*C.vpx_codec_priv_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CodecPriv) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCodecPrivRef converts the C object reference into a raw struct reference without wrapping.
func NewCodecPrivRef(ref unsafe.Pointer) *CodecPriv {
	return (*CodecPriv)(ref)
}

// NewCodecPriv allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCodecPriv() *CodecPriv {
	return (*CodecPriv)(allocCodecPrivMemory(1))
}

// allocCodecPrivMemory allocates memory for type C.vpx_codec_priv_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCodecPrivMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCodecPrivValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCodecPrivValue = unsafe.Sizeof([1]C.vpx_codec_priv_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CodecPriv) PassRef() *C.vpx_codec_priv_t {
	if x == nil {
		x = (*CodecPriv)(allocCodecPrivMemory(1))
	}
	return (*C.vpx_codec_priv_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CodecCtx) Ref() *C.vpx_codec_ctx_t {
	if x == nil {
		return nil
	}
	return (*C.vpx_codec_ctx_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CodecCtx) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCodecCtxRef converts the C object reference into a raw struct reference without wrapping.
func NewCodecCtxRef(ref unsafe.Pointer) *CodecCtx {
	return (*CodecCtx)(ref)
}

// NewCodecCtx allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCodecCtx() *CodecCtx {
	return (*CodecCtx)(allocCodecCtxMemory(1))
}

// allocCodecCtxMemory allocates memory for type C.vpx_codec_ctx_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCodecCtxMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCodecCtxValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCodecCtxValue = unsafe.Sizeof([1]C.vpx_codec_ctx_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CodecCtx) PassRef() *C.vpx_codec_ctx_t {
	if x == nil {
		x = (*CodecCtx)(allocCodecCtxMemory(1))
	}
	return (*C.vpx_codec_ctx_t)(unsafe.Pointer(x))
}

// allocImageMemory allocates memory for type C.vpx_image_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageValue = unsafe.Sizeof([1]C.vpx_image_t{})

type sliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Image) Ref() *C.vpx_image_t {
	if x == nil {
		return nil
	}
	return x.refc09455e3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Image) Free() {
	if x != nil && x.allocsc09455e3 != nil {
		x.allocsc09455e3.(*cgoAllocMap).Free()
		x.refc09455e3 = nil
	}
}

// NewImageRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageRef(ref unsafe.Pointer) *Image {
	if ref == nil {
		return nil
	}
	obj := new(Image)
	obj.refc09455e3 = (*C.vpx_image_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Image) PassRef() (*C.vpx_image_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc09455e3 != nil {
		return x.refc09455e3, nil
	}
	memc09455e3 := allocImageMemory(1)
	refc09455e3 := (*C.vpx_image_t)(memc09455e3)
	allocsc09455e3 := new(cgoAllocMap)
	allocsc09455e3.Add(memc09455e3)

	var cfmt_allocs *cgoAllocMap
	refc09455e3.fmt, cfmt_allocs = (C.vpx_img_fmt_t)(x.Fmt), cgoAllocsUnknown
	allocsc09455e3.Borrow(cfmt_allocs)

	var ccs_allocs *cgoAllocMap
	refc09455e3.cs, ccs_allocs = (C.vpx_color_space_t)(x.Cs), cgoAllocsUnknown
	allocsc09455e3.Borrow(ccs_allocs)

	var c_range_allocs *cgoAllocMap
	refc09455e3._range, c_range_allocs = (C.vpx_color_range_t)(x.Range), cgoAllocsUnknown
	allocsc09455e3.Borrow(c_range_allocs)

	var cw_allocs *cgoAllocMap
	refc09455e3.w, cw_allocs = (C.uint)(x.W), cgoAllocsUnknown
	allocsc09455e3.Borrow(cw_allocs)

	var ch_allocs *cgoAllocMap
	refc09455e3.h, ch_allocs = (C.uint)(x.H), cgoAllocsUnknown
	allocsc09455e3.Borrow(ch_allocs)

	var cbit_depth_allocs *cgoAllocMap
	refc09455e3.bit_depth, cbit_depth_allocs = (C.uint)(x.BitDepth), cgoAllocsUnknown
	allocsc09455e3.Borrow(cbit_depth_allocs)

	var cd_w_allocs *cgoAllocMap
	refc09455e3.d_w, cd_w_allocs = (C.uint)(x.DW), cgoAllocsUnknown
	allocsc09455e3.Borrow(cd_w_allocs)

	var cd_h_allocs *cgoAllocMap
	refc09455e3.d_h, cd_h_allocs = (C.uint)(x.DH), cgoAllocsUnknown
	allocsc09455e3.Borrow(cd_h_allocs)

	var cr_w_allocs *cgoAllocMap
	refc09455e3.r_w, cr_w_allocs = (C.uint)(x.RW), cgoAllocsUnknown
	allocsc09455e3.Borrow(cr_w_allocs)

	var cr_h_allocs *cgoAllocMap
	refc09455e3.r_h, cr_h_allocs = (C.uint)(x.RH), cgoAllocsUnknown
	allocsc09455e3.Borrow(cr_h_allocs)

	var cx_chroma_shift_allocs *cgoAllocMap
	refc09455e3.x_chroma_shift, cx_chroma_shift_allocs = (C.uint)(x.XChromaShift), cgoAllocsUnknown
	allocsc09455e3.Borrow(cx_chroma_shift_allocs)

	var cy_chroma_shift_allocs *cgoAllocMap
	refc09455e3.y_chroma_shift, cy_chroma_shift_allocs = (C.uint)(x.YChromaShift), cgoAllocsUnknown
	allocsc09455e3.Borrow(cy_chroma_shift_allocs)

	var cplanes_allocs *cgoAllocMap
	refc09455e3.planes, cplanes_allocs = *(*[4]*C.uchar)(unsafe.Pointer(&x.Planes)), cgoAllocsUnknown
	allocsc09455e3.Borrow(cplanes_allocs)

	var cstride_allocs *cgoAllocMap
	refc09455e3.stride, cstride_allocs = *(*[4]C.int)(unsafe.Pointer(&x.Stride)), cgoAllocsUnknown
	allocsc09455e3.Borrow(cstride_allocs)

	var cbps_allocs *cgoAllocMap
	refc09455e3.bps, cbps_allocs = (C.int)(x.Bps), cgoAllocsUnknown
	allocsc09455e3.Borrow(cbps_allocs)

	var cuser_priv_allocs *cgoAllocMap
	refc09455e3.user_priv, cuser_priv_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.UserPriv)), cgoAllocsUnknown
	allocsc09455e3.Borrow(cuser_priv_allocs)

	var cimg_data_allocs *cgoAllocMap
	refc09455e3.img_data, cimg_data_allocs = (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.ImgData)).Data)), cgoAllocsUnknown
	allocsc09455e3.Borrow(cimg_data_allocs)

	var cimg_data_owner_allocs *cgoAllocMap
	refc09455e3.img_data_owner, cimg_data_owner_allocs = (C.int)(x.ImgDataOwner), cgoAllocsUnknown
	allocsc09455e3.Borrow(cimg_data_owner_allocs)

	var cself_allocd_allocs *cgoAllocMap
	refc09455e3.self_allocd, cself_allocd_allocs = (C.int)(x.SelfAllocd), cgoAllocsUnknown
	allocsc09455e3.Borrow(cself_allocd_allocs)

	var cfb_priv_allocs *cgoAllocMap
	refc09455e3.fb_priv, cfb_priv_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.FbPriv)), cgoAllocsUnknown
	allocsc09455e3.Borrow(cfb_priv_allocs)

	x.refc09455e3 = refc09455e3
	x.allocsc09455e3 = allocsc09455e3
	return refc09455e3, allocsc09455e3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Image) PassValue() (C.vpx_image_t, *cgoAllocMap) {
	if x.refc09455e3 != nil {
		return *x.refc09455e3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Image) Deref() {
	if x.refc09455e3 == nil {
		return
	}
	x.Fmt = (ImageFormat)(x.refc09455e3.fmt)
	x.Cs = (ColorSpace)(x.refc09455e3.cs)
	x.Range = (ColorRange)(x.refc09455e3._range)
	x.W = (uint32)(x.refc09455e3.w)
	x.H = (uint32)(x.refc09455e3.h)
	x.BitDepth = (uint32)(x.refc09455e3.bit_depth)
	x.DW = (uint32)(x.refc09455e3.d_w)
	x.DH = (uint32)(x.refc09455e3.d_h)
	x.RW = (uint32)(x.refc09455e3.r_w)
	x.RH = (uint32)(x.refc09455e3.r_h)
	x.XChromaShift = (uint32)(x.refc09455e3.x_chroma_shift)
	x.YChromaShift = (uint32)(x.refc09455e3.y_chroma_shift)
	x.Planes = *(*[4]*byte)(unsafe.Pointer(&x.refc09455e3.planes))
	x.Stride = *(*[4]int32)(unsafe.Pointer(&x.refc09455e3.stride))
	x.Bps = (int32)(x.refc09455e3.bps)
	x.UserPriv = (unsafe.Pointer)(unsafe.Pointer(x.refc09455e3.user_priv))
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.ImgData))
	hxfc4425b.Data = uintptr(unsafe.Pointer(x.refc09455e3.img_data))
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ?

	x.ImgDataOwner = (int32)(x.refc09455e3.img_data_owner)
	x.SelfAllocd = (int32)(x.refc09455e3.self_allocd)
	x.FbPriv = (unsafe.Pointer)(unsafe.Pointer(x.refc09455e3.fb_priv))
}

// allocImageRectMemory allocates memory for type C.vpx_image_rect_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageRectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageRectValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageRectValue = unsafe.Sizeof([1]C.vpx_image_rect_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageRect) Ref() *C.vpx_image_rect_t {
	if x == nil {
		return nil
	}
	return x.reff3ce051f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageRect) Free() {
	if x != nil && x.allocsf3ce051f != nil {
		x.allocsf3ce051f.(*cgoAllocMap).Free()
		x.reff3ce051f = nil
	}
}

// NewImageRectRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageRectRef(ref unsafe.Pointer) *ImageRect {
	if ref == nil {
		return nil
	}
	obj := new(ImageRect)
	obj.reff3ce051f = (*C.vpx_image_rect_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageRect) PassRef() (*C.vpx_image_rect_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff3ce051f != nil {
		return x.reff3ce051f, nil
	}
	memf3ce051f := allocImageRectMemory(1)
	reff3ce051f := (*C.vpx_image_rect_t)(memf3ce051f)
	allocsf3ce051f := new(cgoAllocMap)
	allocsf3ce051f.Add(memf3ce051f)

	var cx_allocs *cgoAllocMap
	reff3ce051f.x, cx_allocs = (C.uint)(x.X), cgoAllocsUnknown
	allocsf3ce051f.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	reff3ce051f.y, cy_allocs = (C.uint)(x.Y), cgoAllocsUnknown
	allocsf3ce051f.Borrow(cy_allocs)

	var cw_allocs *cgoAllocMap
	reff3ce051f.w, cw_allocs = (C.uint)(x.W), cgoAllocsUnknown
	allocsf3ce051f.Borrow(cw_allocs)

	var ch_allocs *cgoAllocMap
	reff3ce051f.h, ch_allocs = (C.uint)(x.H), cgoAllocsUnknown
	allocsf3ce051f.Borrow(ch_allocs)

	x.reff3ce051f = reff3ce051f
	x.allocsf3ce051f = allocsf3ce051f
	return reff3ce051f, allocsf3ce051f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageRect) PassValue() (C.vpx_image_rect_t, *cgoAllocMap) {
	if x.reff3ce051f != nil {
		return *x.reff3ce051f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageRect) Deref() {
	if x.reff3ce051f == nil {
		return
	}
	x.X = (uint32)(x.reff3ce051f.x)
	x.Y = (uint32)(x.reff3ce051f.y)
	x.W = (uint32)(x.reff3ce051f.w)
	x.H = (uint32)(x.reff3ce051f.h)
}

// allocCodecStreamInfoMemory allocates memory for type C.vpx_codec_stream_info_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCodecStreamInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCodecStreamInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCodecStreamInfoValue = unsafe.Sizeof([1]C.vpx_codec_stream_info_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CodecStreamInfo) Ref() *C.vpx_codec_stream_info_t {
	if x == nil {
		return nil
	}
	return x.ref342546e4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CodecStreamInfo) Free() {
	if x != nil && x.allocs342546e4 != nil {
		x.allocs342546e4.(*cgoAllocMap).Free()
		x.ref342546e4 = nil
	}
}

// NewCodecStreamInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCodecStreamInfoRef(ref unsafe.Pointer) *CodecStreamInfo {
	if ref == nil {
		return nil
	}
	obj := new(CodecStreamInfo)
	obj.ref342546e4 = (*C.vpx_codec_stream_info_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CodecStreamInfo) PassRef() (*C.vpx_codec_stream_info_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref342546e4 != nil {
		return x.ref342546e4, nil
	}
	mem342546e4 := allocCodecStreamInfoMemory(1)
	ref342546e4 := (*C.vpx_codec_stream_info_t)(mem342546e4)
	allocs342546e4 := new(cgoAllocMap)
	allocs342546e4.Add(mem342546e4)

	var csz_allocs *cgoAllocMap
	ref342546e4.sz, csz_allocs = (C.uint)(x.Sz), cgoAllocsUnknown
	allocs342546e4.Borrow(csz_allocs)

	var cw_allocs *cgoAllocMap
	ref342546e4.w, cw_allocs = (C.uint)(x.W), cgoAllocsUnknown
	allocs342546e4.Borrow(cw_allocs)

	var ch_allocs *cgoAllocMap
	ref342546e4.h, ch_allocs = (C.uint)(x.H), cgoAllocsUnknown
	allocs342546e4.Borrow(ch_allocs)

	var cis_kf_allocs *cgoAllocMap
	ref342546e4.is_kf, cis_kf_allocs = (C.uint)(x.IsKf), cgoAllocsUnknown
	allocs342546e4.Borrow(cis_kf_allocs)

	x.ref342546e4 = ref342546e4
	x.allocs342546e4 = allocs342546e4
	return ref342546e4, allocs342546e4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CodecStreamInfo) PassValue() (C.vpx_codec_stream_info_t, *cgoAllocMap) {
	if x.ref342546e4 != nil {
		return *x.ref342546e4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CodecStreamInfo) Deref() {
	if x.ref342546e4 == nil {
		return
	}
	x.Sz = (uint32)(x.ref342546e4.sz)
	x.W = (uint32)(x.ref342546e4.w)
	x.H = (uint32)(x.ref342546e4.h)
	x.IsKf = (uint32)(x.ref342546e4.is_kf)
}

// allocCodecDecCfgMemory allocates memory for type C.vpx_codec_dec_cfg_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCodecDecCfgMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCodecDecCfgValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCodecDecCfgValue = unsafe.Sizeof([1]C.vpx_codec_dec_cfg_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CodecDecCfg) Ref() *C.vpx_codec_dec_cfg_t {
	if x == nil {
		return nil
	}
	return x.ref7df355ac
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CodecDecCfg) Free() {
	if x != nil && x.allocs7df355ac != nil {
		x.allocs7df355ac.(*cgoAllocMap).Free()
		x.ref7df355ac = nil
	}
}

// NewCodecDecCfgRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCodecDecCfgRef(ref unsafe.Pointer) *CodecDecCfg {
	if ref == nil {
		return nil
	}
	obj := new(CodecDecCfg)
	obj.ref7df355ac = (*C.vpx_codec_dec_cfg_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CodecDecCfg) PassRef() (*C.vpx_codec_dec_cfg_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7df355ac != nil {
		return x.ref7df355ac, nil
	}
	mem7df355ac := allocCodecDecCfgMemory(1)
	ref7df355ac := (*C.vpx_codec_dec_cfg_t)(mem7df355ac)
	allocs7df355ac := new(cgoAllocMap)
	allocs7df355ac.Add(mem7df355ac)

	var cthreads_allocs *cgoAllocMap
	ref7df355ac.threads, cthreads_allocs = (C.uint)(x.Threads), cgoAllocsUnknown
	allocs7df355ac.Borrow(cthreads_allocs)

	var cw_allocs *cgoAllocMap
	ref7df355ac.w, cw_allocs = (C.uint)(x.W), cgoAllocsUnknown
	allocs7df355ac.Borrow(cw_allocs)

	var ch_allocs *cgoAllocMap
	ref7df355ac.h, ch_allocs = (C.uint)(x.H), cgoAllocsUnknown
	allocs7df355ac.Borrow(ch_allocs)

	x.ref7df355ac = ref7df355ac
	x.allocs7df355ac = allocs7df355ac
	return ref7df355ac, allocs7df355ac

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CodecDecCfg) PassValue() (C.vpx_codec_dec_cfg_t, *cgoAllocMap) {
	if x.ref7df355ac != nil {
		return *x.ref7df355ac, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CodecDecCfg) Deref() {
	if x.ref7df355ac == nil {
		return
	}
	x.Threads = (uint32)(x.ref7df355ac.threads)
	x.W = (uint32)(x.ref7df355ac.w)
	x.H = (uint32)(x.ref7df355ac.h)
}

func (x CodecPutFrameCbFn) PassRef() (ref *C.vpx_codec_put_frame_cb_fn_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if codecPutFrameCbFnF425E4FCFunc == nil {
		codecPutFrameCbFnF425E4FCFunc = x
	}
	return (*C.vpx_codec_put_frame_cb_fn_t)(C.vpx_codec_put_frame_cb_fn_t_f425e4fc), nil
}

func (x CodecPutFrameCbFn) PassValue() (ref C.vpx_codec_put_frame_cb_fn_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if codecPutFrameCbFnF425E4FCFunc == nil {
		codecPutFrameCbFnF425E4FCFunc = x
	}
	return (C.vpx_codec_put_frame_cb_fn_t)(C.vpx_codec_put_frame_cb_fn_t_f425e4fc), nil
}

func NewCodecPutFrameCbFnRef(ref unsafe.Pointer) *CodecPutFrameCbFn {
	return (*CodecPutFrameCbFn)(ref)
}

//export codecPutFrameCbFnF425E4FC
func codecPutFrameCbFnF425E4FC(cuserPriv unsafe.Pointer, cimg *C.vpx_image_t) {
	if codecPutFrameCbFnF425E4FCFunc != nil {
		userPrivf425e4fc := (unsafe.Pointer)(unsafe.Pointer(cuserPriv))
		imgf425e4fc := NewImageRef(unsafe.Pointer(cimg))
		codecPutFrameCbFnF425E4FCFunc(userPrivf425e4fc, imgf425e4fc)
		return
	}
	panic("callback func has not been set (race?)")
}

var codecPutFrameCbFnF425E4FCFunc CodecPutFrameCbFn

func (x CodecPutSliceCbFn) PassRef() (ref *C.vpx_codec_put_slice_cb_fn_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if codecPutSliceCbFn1C2E1E21Func == nil {
		codecPutSliceCbFn1C2E1E21Func = x
	}
	return (*C.vpx_codec_put_slice_cb_fn_t)(C.vpx_codec_put_slice_cb_fn_t_1c2e1e21), nil
}

func (x CodecPutSliceCbFn) PassValue() (ref C.vpx_codec_put_slice_cb_fn_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if codecPutSliceCbFn1C2E1E21Func == nil {
		codecPutSliceCbFn1C2E1E21Func = x
	}
	return (C.vpx_codec_put_slice_cb_fn_t)(C.vpx_codec_put_slice_cb_fn_t_1c2e1e21), nil
}

func NewCodecPutSliceCbFnRef(ref unsafe.Pointer) *CodecPutSliceCbFn {
	return (*CodecPutSliceCbFn)(ref)
}

//export codecPutSliceCbFn1C2E1E21
func codecPutSliceCbFn1C2E1E21(cuserPriv unsafe.Pointer, cimg *C.vpx_image_t, cvalid *C.vpx_image_rect_t, cupdate *C.vpx_image_rect_t) {
	if codecPutSliceCbFn1C2E1E21Func != nil {
		userPriv1c2e1e21 := (unsafe.Pointer)(unsafe.Pointer(cuserPriv))
		img1c2e1e21 := NewImageRef(unsafe.Pointer(cimg))
		valid1c2e1e21 := NewImageRectRef(unsafe.Pointer(cvalid))
		update1c2e1e21 := NewImageRectRef(unsafe.Pointer(cupdate))
		codecPutSliceCbFn1C2E1E21Func(userPriv1c2e1e21, img1c2e1e21, valid1c2e1e21, update1c2e1e21)
		return
	}
	panic("callback func has not been set (race?)")
}

var codecPutSliceCbFn1C2E1E21Func CodecPutSliceCbFn

// allocCodecFrameBufferMemory allocates memory for type C.vpx_codec_frame_buffer_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCodecFrameBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCodecFrameBufferValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCodecFrameBufferValue = unsafe.Sizeof([1]C.vpx_codec_frame_buffer_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CodecFrameBuffer) Ref() *C.vpx_codec_frame_buffer_t {
	if x == nil {
		return nil
	}
	return x.refd319b8f1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CodecFrameBuffer) Free() {
	if x != nil && x.allocsd319b8f1 != nil {
		x.allocsd319b8f1.(*cgoAllocMap).Free()
		x.refd319b8f1 = nil
	}
}

// NewCodecFrameBufferRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCodecFrameBufferRef(ref unsafe.Pointer) *CodecFrameBuffer {
	if ref == nil {
		return nil
	}
	obj := new(CodecFrameBuffer)
	obj.refd319b8f1 = (*C.vpx_codec_frame_buffer_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CodecFrameBuffer) PassRef() (*C.vpx_codec_frame_buffer_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd319b8f1 != nil {
		return x.refd319b8f1, nil
	}
	memd319b8f1 := allocCodecFrameBufferMemory(1)
	refd319b8f1 := (*C.vpx_codec_frame_buffer_t)(memd319b8f1)
	allocsd319b8f1 := new(cgoAllocMap)
	allocsd319b8f1.Add(memd319b8f1)

	var cdata_allocs *cgoAllocMap
	refd319b8f1.data, cdata_allocs = (*C.uint8_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Data)).Data)), cgoAllocsUnknown
	allocsd319b8f1.Borrow(cdata_allocs)

	var csize_allocs *cgoAllocMap
	refd319b8f1.size, csize_allocs = (C.size_t)(x.Size), cgoAllocsUnknown
	allocsd319b8f1.Borrow(csize_allocs)

	var cpriv_allocs *cgoAllocMap
	refd319b8f1.priv, cpriv_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Priv)), cgoAllocsUnknown
	allocsd319b8f1.Borrow(cpriv_allocs)

	x.refd319b8f1 = refd319b8f1
	x.allocsd319b8f1 = allocsd319b8f1
	return refd319b8f1, allocsd319b8f1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CodecFrameBuffer) PassValue() (C.vpx_codec_frame_buffer_t, *cgoAllocMap) {
	if x.refd319b8f1 != nil {
		return *x.refd319b8f1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CodecFrameBuffer) Deref() {
	if x.refd319b8f1 == nil {
		return
	}
	hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&x.Data))
	hxf95e7c8.Data = uintptr(unsafe.Pointer(x.refd319b8f1.data))
	hxf95e7c8.Cap = 0x7fffffff
	// hxf95e7c8.Len = ?

	x.Size = (uint)(x.refd319b8f1.size)
	x.Priv = (unsafe.Pointer)(unsafe.Pointer(x.refd319b8f1.priv))
}

func (x GetFrameBufferCbFn) PassRef() (ref *C.vpx_get_frame_buffer_cb_fn_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if getFrameBufferCbFnF5FE44EBFunc == nil {
		getFrameBufferCbFnF5FE44EBFunc = x
	}
	return (*C.vpx_get_frame_buffer_cb_fn_t)(C.vpx_get_frame_buffer_cb_fn_t_f5fe44eb), nil
}

func (x GetFrameBufferCbFn) PassValue() (ref C.vpx_get_frame_buffer_cb_fn_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if getFrameBufferCbFnF5FE44EBFunc == nil {
		getFrameBufferCbFnF5FE44EBFunc = x
	}
	return (C.vpx_get_frame_buffer_cb_fn_t)(C.vpx_get_frame_buffer_cb_fn_t_f5fe44eb), nil
}

func NewGetFrameBufferCbFnRef(ref unsafe.Pointer) *GetFrameBufferCbFn {
	return (*GetFrameBufferCbFn)(ref)
}

//export getFrameBufferCbFnF5FE44EB
func getFrameBufferCbFnF5FE44EB(cpriv unsafe.Pointer, cminSize C.size_t, cfb *C.vpx_codec_frame_buffer_t) C.int {
	if getFrameBufferCbFnF5FE44EBFunc != nil {
		privf5fe44eb := (unsafe.Pointer)(unsafe.Pointer(cpriv))
		minSizef5fe44eb := (uint)(cminSize)
		fbf5fe44eb := NewCodecFrameBufferRef(unsafe.Pointer(cfb))
		retf5fe44eb := getFrameBufferCbFnF5FE44EBFunc(privf5fe44eb, minSizef5fe44eb, fbf5fe44eb)
		ret, _ := (C.int)(retf5fe44eb), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var getFrameBufferCbFnF5FE44EBFunc GetFrameBufferCbFn

func (x ReleaseFrameBufferCbFn) PassRef() (ref *C.vpx_release_frame_buffer_cb_fn_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if releaseFrameBufferCbFnED49B503Func == nil {
		releaseFrameBufferCbFnED49B503Func = x
	}
	return (*C.vpx_release_frame_buffer_cb_fn_t)(C.vpx_release_frame_buffer_cb_fn_t_ed49b503), nil
}

func (x ReleaseFrameBufferCbFn) PassValue() (ref C.vpx_release_frame_buffer_cb_fn_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if releaseFrameBufferCbFnED49B503Func == nil {
		releaseFrameBufferCbFnED49B503Func = x
	}
	return (C.vpx_release_frame_buffer_cb_fn_t)(C.vpx_release_frame_buffer_cb_fn_t_ed49b503), nil
}

func NewReleaseFrameBufferCbFnRef(ref unsafe.Pointer) *ReleaseFrameBufferCbFn {
	return (*ReleaseFrameBufferCbFn)(ref)
}

//export releaseFrameBufferCbFnED49B503
func releaseFrameBufferCbFnED49B503(cpriv unsafe.Pointer, cfb *C.vpx_codec_frame_buffer_t) C.int {
	if releaseFrameBufferCbFnED49B503Func != nil {
		prived49b503 := (unsafe.Pointer)(unsafe.Pointer(cpriv))
		fbed49b503 := NewCodecFrameBufferRef(unsafe.Pointer(cfb))
		reted49b503 := releaseFrameBufferCbFnED49B503Func(prived49b503, fbed49b503)
		ret, _ := (C.int)(reted49b503), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var releaseFrameBufferCbFnED49B503Func ReleaseFrameBufferCbFn

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = uintptr(unsafe.Pointer(p))
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - h.Data)
	}
	return
}

type stringHeader struct {
	Data uintptr
	Len  int
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(unsafe.Pointer(h.Data)), C.int(h.Len))
}

// unpackPUint8String represents the data from Go string as *C.uint8_t and avoids copying.
func unpackPUint8String(str string) (*C.uint8_t, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.uint8_t)(unsafe.Pointer(h.Data)), cgoAllocsUnknown
}
